Ajker topic :=> 
1. Dynamic Types
2. Type Conversion
3. NaN and -0
4. Closure
5. IIFE
6. Curring




1. Dynamic Types :
amader world e 2 type er language ase . ekta hocche Dynamic Types language and arekta hocche Static Types language

#Dynamic Types language : jei programming language e variable declare er somoy type declare korte hoy na setake bole Dynamic Types language . javascript ekta Dynamic types language . javascript compiler nijer value ta porjobekkhon kore decide kore ney sei variable er type ki hobe . jemon :
let randomVariable = 2
randomVariable = "h"
randomVariable = true
randomVariable = []
jodio typescript aisha javascript er ai gap ta puron kore 

#Static Types language : jei language e types declare kora hoy jemon C, C++ , Java etc...

##Important Notes : 
keno null er type object ? 
amra jokhon typeof null dei tokhon output object ashe . karon ?
karon holo javascript kora hoise C and C++ diye . C and C++ er moddhe null er type object hoye thake . tai sei same jinishtaii javascript e replicate hoise . eta ekta legecy bug 



2. Type Conversion : 

JavaScript-এ টাইপ কনভার্শন একটি গুরুত্বপূর্ণ বিষয়। টাইপ কনভার্শন মানে হল একটি ডেটা টাইপকে অন্য ডেটা টাইপে রূপান্তর করা। JavaScript-এ এটি দুইভাবে ঘটে:

Implicit Type Conversion (Type Coercion): যখন JavaScript স্বয়ংক্রিয়ভাবে টাইপ কনভার্শন করে।
Explicit Type Conversion: যখন ডেভেলপার সরাসরি টাইপ কনভার্শনের নির্দেশ দেন।

# Implicit Type Conversion (Type Coercion)
JavaScript কিছু অপারেশনের সময় ডেটার টাইপ স্বয়ংক্রিয়ভাবে পরিবর্তন করে।

উদাহরণ ১: String থেকে Number
console.log("5" - 2); // Output: 3
কেন?
"5" একটি স্ট্রিং, কিন্তু - অপারেটর ব্যবহার করার সময় JavaScript এটিকে Number-এ রূপান্তর করে।

উদাহরণ ২: Number থেকে String
console.log("Hello" + 5); // Output: "Hello5"
কেন?
+ অপারেটর ব্যবহার করলে JavaScript সংখ্যাকে স্ট্রিং-এ রূপান্তর করে।

##Important Notes : 
+ operator diye mainly 2 ta number add kora jay and 2 ta string concatination kora jay . jokhon string + number kora hoy tokhon type Conversion er khetre string beshi priority jay . tai sudhu sei khetre string hoye jay . jemon "2" + 3 = "23" kintu "2" - 1 = 1 hobe . 

উদাহরণ ৩: Boolean থেকে Number
console.log(true + 1); // Output: 2
console.log(false + 1); // Output: 1
কেন?
true-কে 1 এবং false-কে 0 হিসেবে গণ্য করা হয়।


# Explicit Type Conversion
এটি তখন ঘটে যখন ডেভেলপার নিজে টাইপ পরিবর্তন করতে চান।

উদাহরণ ১: String থেকে Number
let str = "123";
let num = Number(str);
console.log(num); // Output: 123
console.log(typeof num); // Output: number

উদাহরণ ২: Number থেকে String
let num = 123;
let str = String(num);
console.log(str); // Output: "123"
console.log(typeof str); // Output: string

উদাহরণ ৩: Boolean থেকে Number
let isTrue = true;
let num = Number(isTrue);
console.log(num); // Output: 1

উদাহরণ ৪: Number থেকে Boolean
let num = 0;
let bool = Boolean(num);
console.log(bool); // Output: false

## Type Conversion Table dekha jabe ./images/typeConversionTable.png file er moddhe


কিছু গুরুত্বপূর্ণ পয়েন্ট
Falsy Values: JavaScript-এ 0, null, undefined, false, "" (খালি স্ট্রিং), এবং NaN হলো "Falsy"।

console.log(Boolean(0)); // Output: false
console.log(Boolean("")); // Output: false
Truthy Values: Falsy বাদে সবকিছু "Truthy"।

console.log(Boolean(1)); // Output: true
console.log(Boolean("Hello")); // Output: true
NaN (Not-a-Number): যখন সংখ্যা হিসেবে কনভার্ট করা যায় না।

let result = Number("abc");
console.log(result); // Output: NaN
এই বিষয়গুলো বোঝার মাধ্যমে JavaScript-এ টাইপ কনভার্শন আরও স্পষ্ট হবে।








4. Closure 

Definition : A function with some preservered values creates a closure. 
A Closure is created when a function preserves variables outside of its scope

Closure হল প্রোগ্রামিংয়ের একটি ধারণা, যা একটি ফাংশনের সাথে তার lexical scope (যেখানে ফাংশনটি ডিফাইন করা হয়েছে) সংযুক্ত করে। Closure মূলত higher-order ফাংশন এবং functional programming-এ ব্যবহৃত হয়। এটি JavaScript সহ অনেক প্রোগ্রামিং ভাষায় পাওয়া যায়।

Closure-এর বৈশিষ্ট্য:
Lexical Scope Access: Closure একটি nested function, যা তার parent function-এর ভেরিয়েবল এবং scope-এ অ্যাক্সেস করতে পারে, এমনকি parent function-এর execution শেষ হওয়ার পরেও।

State Preservation: Closure state (অবস্থা) সংরক্ষণ করতে পারে, যেমন একটি counter ফাংশনের ক্ষেত্রে।

Encapsulation: Closure encapsulation করতে সাহায্য করে, যা private data তৈরি এবং ম্যানেজ করতে ব্যবহৃত হয়।

Example : 
function createCounter() {
    let count = 0; // এটি parent scope-এর একটি ভেরিয়েবল
    return function() {
        count++; // nested ফাংশন এটি অ্যাক্সেস করতে পারে
        return count;
    };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3



Closure এর ব্যবহার:
Private Variables: Closure ব্যবহার করে এমন ভেরিয়েবল তৈরি করা যায় যা বাইরের কোনো কোড থেকে অ্যাক্সেসযোগ্য নয়।

function Person(name) {
    let privateName = name; // Private variable
    return {
        getName: function() {
            return privateName;
        },
        setName: function(newName) {
            privateName = newName;
        }
    };
}

const person = Person("John");
console.log(person.getName()); // John
person.setName("Doe");
console.log(person.getName()); // Doe

Callbacks: Asynchronous কোডে callback ফাংশনের সাথে closure ব্যবহার করা হয়।

Event Handlers: DOM element এর সাথে কাজ করার সময় closure প্রচুর ব্যবহৃত হয়।

Closure বুঝতে গেলে:
Scope কীভাবে কাজ করে তা ভালোভাবে বুঝতে হবে।
Functional Programming এর কনসেপ্টগুলো নিয়ে পরিষ্কার ধারণা থাকা দরকার।
Closure জটিল মনে হতে পারে, কিন্তু এটি শক্তিশালী এবং ব্যবহারিক একটি টুল, যা কোডকে modular এবং secure করতে সাহায্য করে।


closure er moddhe ekta term ashe . seta holo ডেটা encapsulation . er mane ki ? etaii akhon deeply dekhbo 

ডেটা encapsulation মানে হলো ডেটা (ভেরিয়েবল বা অবজেক্টের তথ্য) এবং সেই ডেটার উপর কাজ করা মেথডগুলোকে একসাথে বাঁধা এবং বাইরের অবাঞ্ছিত অ্যাক্সেস বা পরিবর্তন থেকে সেগুলোকে সুরক্ষিত রাখা। এটি প্রোগ্রামিংয়ের একটি গুরুত্বপূর্ণ ধারণা, যা মূলত ডেটার গোপনীয়তা নিশ্চিত করে এবং কোড ব্যবস্থাপনা সহজ করে তোলে।


ডেটা Encapsulation-এর মূল ধারণা
ডেটা লুকানো (Data Hiding):

প্রাইভেট ভেরিয়েবল বা প্রোপার্টি তৈরি করা, যাতে ডেটা সরাসরি বাইরের থেকে অ্যাক্সেস করা না যায়।
শুধুমাত্র নির্দিষ্ট মেথড বা ফাংশনের মাধ্যমে ডেটা পড়া বা আপডেট করা সম্ভব।
গোপনীয়তা (Privacy):

ডেটাকে encapsulate করে রাখা হলে বাইরের কেউ সরাসরি ডেটাকে পরিবর্তন করতে পারে না, ফলে ডেটা সুরক্ষিত থাকে।
নিয়ন্ত্রিত অ্যাক্সেস (Controlled Access):

ডেটা ব্যবহারের জন্য নির্দিষ্ট মেথড বা API তৈরি করা হয়, যা ডেটাকে নিয়ম মেনে পড়তে বা পরিবর্তন করতে দেয়।

mane holo amon ekta function jar scope er moddhe kono variable thakbe jeta shorashori function er baire keu access korte parbe na . jodi korte chay tahole take ekta rules follow korte hobe . jemon oi function kichu closure function diye dilo ja diye ami oi variable ke rules motabek update delete read korte pari . data read write update delete korar ai rules tai holo ডেটা encapsulation . 

Example : 
function BankAccount(initialBalance) {
    let balance = initialBalance; // Private variable

    return {
        deposit: function(amount) {
            if (amount > 0) {
                balance += amount; // Balance update
                return `Deposited: ${amount}, New Balance: ${balance}`;
            } else {
                return "Invalid deposit amount!";
            }
        },
        getBalance: function() {
            return balance; // Balance রিটার্ন
        }
    };
}

const account = BankAccount(1000);
console.log(account.getBalance()); // 1000
console.log(account.deposit(500)); // Deposited: 500, New Balance: 1500
// console.log(account.balance); // Undefined, কারণ এটি encapsulated/private


ekhane BankAccount er balance keu directly access korte pare na . jodi access korte chay tahole take kichu rules follow korte hobe . jemon balance dekhte chaile tar vitor getBalance method use korte hobe, balance er value update korte hobe deposit method use kora lagbe . ekhane ডেটা encapsulation toiri hoyeche

ডেটা Encapsulation-এর সুবিধা
সুরক্ষা: ডেটা সরাসরি বাইরের কোড থেকে পরিবর্তন করা সম্ভব নয়।
যেমন: উপরের উদাহরণে কেউ সরাসরি balance পরিবর্তন করতে পারবে না।
নিয়ন্ত্রিত অ্যাক্সেস: ডেটা ব্যবহারের জন্য মেথডের নিয়ম মেনে চলতে হয়।
ডিবাগিং সহজ: ভুল বা অবাঞ্ছিত পরিবর্তন থেকে ডেটাকে সুরক্ষিত রাখার ফলে ডিবাগিং সহজ হয়।
মডুলার ডিজাইন: কোডকে ছোট ছোট মডিউলে ভাগ করা যায়, যা ব্যবস্থাপনা সহজ করে।


ডেটা Encapsulation না থাকলে কী সমস্যা হয়?

function BankAccount(initialBalance) {
    this.balance = initialBalance; // Public variable
}

const account = new BankAccount(1000);
console.log(account.balance); // 1000
account.balance = -500; // Balance সরাসরি পরিবর্তন করা হলো
console.log(account.balance); // -500 (এটি ভুল ডেটা হতে পারে)

এখানে balance public হওয়ায় যে কেউ সরাসরি এর মান পরিবর্তন করতে পারছে। এটি প্রোগ্রামের লজিক ভেঙে দিতে পারে।



ক্লোজার দিয়ে ডেটা Encapsulation নিশ্চিত করা : 

function Counter() {
    let count = 0; // Private variable

    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = Counter();
console.log(counter.increment()); // 1
console.log(counter.decrement()); // 0
// console.log(counter.count); // Undefined


সংক্ষেপে:
ডেটা encapsulation মানে হলো ডেটাকে বাইরের অবাঞ্ছিত অ্যাক্সেস বা পরিবর্তন থেকে লুকিয়ে রাখা এবং নিয়ন্ত্রিত অ্যাক্সেসের ব্যবস্থা করা। এটি প্রোগ্রামের ডেটা সুরক্ষা এবং ব্যবস্থাপনাকে সহজ করে তোলে।




#Important Note : akhn closure diye private variable create korar kichu example deya holo...


Closure দিয়ে private variable তৈরি করার মাধ্যমে ডেটা encapsulation এবং সুরক্ষা নিশ্চিত করা যায়। এখানে সহজ থেকে কঠিন উদাহরণ দেওয়া হলো, যাতে আপনি বিভিন্ন ধাপে বিষয়টি ভালোভাবে বুঝতে পারেন।

১. সহজ উদাহরণ: Name Setter এবং Getter
javascript
Copy code
function createPerson(name) {
    let privateName = name; // Private variable

    return {
        getName: function() {
            return privateName;
        },
        setName: function(newName) {
            privateName = newName;
        }
    };
}

const person = createPerson("Alice");
console.log(person.getName()); // Alice
person.setName("Bob");
console.log(person.getName()); // Bob
// console.log(person.privateName); // Access করতে পারবেন না

ব্যাখ্যা:
privateName ভেরিয়েবল createPerson ফাংশনের scope-এর মধ্যে encapsulated। শুধুমাত্র getName এবং setName ফাংশনের মাধ্যমে এটি অ্যাক্সেস করা যায়।





// IIFE

JavaScript এ IIFE (Immediately Invoked Function Expression) কী?
IIFE মানে হলো এমন একটি Function যেটি ডিক্লেয়ার করার সাথে সাথে স্বয়ংক্রিয়ভাবে কল (invoke) হয়। এটি সাধারণত এমন কোড ব্লকে ব্যবহৃত হয় যেখানে আমরা কোনো কোডকে isolate করতে চাই বা একটি আলাদা scope তৈরি করতে চাই।

IIFE এর বৈশিষ্ট্য:
এটি একটি function expression হিসেবে লেখা হয়।
এটি লেখা মাত্রই execute হয়ে যায়।
Scope isolation এর জন্য এটি ব্যবহার করা হয়, অর্থাৎ, এর ভেতরের ভেরিয়েবল এবং কোড বাইরের কোনো কোডকে প্রভাবিত করে না এবং বাইরের কোডও এটিকে প্রভাবিত করতে পারে না।

IIFE এর সিনট্যাক্স:
IIFE সাধারণত দুটি পদ্ধতিতে লেখা হয়:

১. Parentheses দিয়ে wrap করা:
(function() {
    console.log("IIFE is running!");
})();

২. Parentheses এর শেষে রাখে:
(function() {
    console.log("Another way of writing IIFE!");
}());




