1. kono html file jokhon browser e run kora hoy tokhon er sathe onk gula javascript file thakte pare . mone rakhte hobe browser sob somoy sobgula javascript file ke eksathe kore ekta file e aina download kore . jar karone kono ekta file e jodi same variable er kono variable onno kono file e hoy tahole tara overwrite hobe . eta bujhar jonno app.js er moddhe fileName ekta variable er data dilam 'Tanvir' and app2.js er moddhe fileName='Ahmed' dilam . akhn app2.js file er moddhe setTimeout e 2 second diye fileName console log korar por dekha jay app.js er filename er value ekhane print hocche . karon jotokkhon e app2.js file run hoise totokkhon porjonto app2.js suspend obosthay chilo. 

2. jokhon var, let, const use na kore kono variable declare kora hoy tokhon seta window object er moddhe set hoy . jemon name='tanvir' ,, ekhane name variable ta window object e set hoise . akhn jodi ami console.log(window.name) dei tahole answer ashbe 'tanvir' . similerly var diyeo kono variable declare korle seta window object er moddhe set hoy . etai problem create kore karon ekta project er onk gula js file jehetu ekta single file er moddhe attach hoye browser e run kore tai browser sei single js file er jonno ektaii window object dibe . and sei js file gular moddhe variable overwrite houyar chance thake jehetu sob gulaii window object er moddhe save hobe

3. let or const kokhono block scope e hoy na , borong let or const block scope create kore . jemon :=> 
    function sayHi(){
        if(true){
            var helloWorld = 'Hello World!'
        }
        console.log(helloWorld)
    }
    sayHi()
ai code tar 2 or 3 number line e debugger lagaiya jodi run kora hoy tokhon sources tab e giya dekha jabe only global scope and local scope ache . ekhane helloWorld variable ta local scope e ache karon var holo local scope . and global scope to always thakeii . kintu...
    function sayHi(){
        if(true){
            var helloWorld = 'Hello World!'
            let asd = 'asdfg'
        }
        console.log(helloWorld)
    }
    sayHi() 
ai code run kore 2 number line e debugger lagaile sources tab er moddhe ekta arekta scope dekha jabe jar nam block scope . ekhane if() or for() or jekono block er jonno block scope create hoy na . borong let const er jonno block scope create hoy
and jokhon debugger let asd = 'asdfg' line ta execute kore sathe sathe sekhan theke block scope chole jay 

4. Data Types 

# Primitive Data Types --- undefined, null, number, BigInt, Symbol, String, Boolean
# Non-Primitive Data Types --- object

ekhane undefined and null holo special type er data type . undefined and null majhe moddhe as a value treat hoye thake . 

undefined and null er moddhe parthokko ki ? 
undefined holo default value and null holo explicit value . tar mane ki ? tar mane holo jodi ekta variable declare kore sekhane kono value add na kori tahole by default sei variable er value undefined . and jodi amra explicitly kono variable er value null dei tokhon sei variable er valu null hobe . explicitly mane holo nije theke manually deya . kintu undefined maneo khali, null maneo khali . 

null ভেরিয়েবলের জন্য মেমরি বরাদ্দ হয়, কারণ এটি অবজেক্ট টাইপের একটি মান।
undefined-এর জন্যও মেমরি বরাদ্দ হয়, তবে এটি খুব সামান্য, কারণ এটি ডিফল্ট মান।

1. null:
null মানে হলো ইচ্ছাকৃতভাবে "কিছু নেই" সেট করা।
এটি সাধারণত ব্যবহার করা হয় যখন আপনি কোনো ভেরিয়েবলের ভ্যালু খালি বা ফাঁকা রাখতে চান এবং তা স্পষ্টভাবে দেখাতে চান।
উদাহরণ:
let myVariable = null; // ইচ্ছাকৃতভাবে ফাঁকা করা হয়েছে
কিছু বৈশিষ্ট্য:
এটা একটা অবজেক্ট টাইপের মান। (হ্যাঁ, এটা মজার হলেও সত্যি!)
এর মানে হলো "খালি" বা "অকার্যকর অবস্থা"।
ব্যবহার:
ডাটাবেজ থেকে ডাটা না পাওয়া গেলে সেটাকে null করা হয়।
কোনো ভেরিয়েবল খালি বা রিসেট করতে হলে null সেট করা হয়।

2. undefined:
undefined মানে হলো ভেরিয়েবল ঘোষণা করা হয়েছে কিন্তু কোনো মান সেট করা হয়নি।
এটি JavaScript ডিফল্টভাবে ব্যবহার করে যদি ভেরিয়েবলে কোনো মান অ্যাসাইন না করা হয়।
উদাহরণ:
let myVariable; // মান সেট করা হয়নি, তাই undefined
console.log(myVariable); // undefined দেখাবে
কিছু বৈশিষ্ট্য:
এটা টাইপ হিসেবে undefined।
যদি কোনো ফাংশন কিছু রিটার্ন না করে, তখন তা undefined রিটার্ন করে।
ব্যবহার:
ভেরিয়েবল ঘোষণা করা হয়েছে কিন্তু মান দেয়া হয়নি।
অবজেক্টের এমন কোনো প্রপার্টি অ্যাক্সেস করা হলে যা নেই, তা undefined দেখাবে।


মূল পার্থক্য টেবিল আকারে:
বৈশিষ্ট্য        null	                            undefined
অর্থ	      ইচ্ছাকৃতভাবে খালি করা।	            কোনো মান সেট করা হয়নি।
টাইপ	     অবজেক্ট	                         undefined টাইপ
ডিফল্ট মান?	  না, এটি ম্যানুয়ালি সেট করতে হয়।	      হ্যাঁ, ডিফল্ট মান।
ব্যবহার	       ভেরিয়েবল বা অবজেক্ট ফাঁকা করতে।	    মান অ্যাসাইন করা হয়নি এমন ক্ষেত্রে।

১. null এবং মেমরি স্পেস:
যদি কোনো ভেরিয়েবলের মান null সেট করা হয়, তাহলে মেমরি স্পেস ব্যবহার করা হয়।

null আসলে একটি স্পেশাল অবজেক্ট টাইপের মান।
যখন ভেরিয়েবলে null রাখা হয়, তখন JavaScript সেই ভেরিয়েবলের জন্য রেফারেন্স টাইপ (যেমন অবজেক্ট) হিসেবে মেমরি বরাদ্দ করে।
যদিও null কোনো ডাটা ধরে রাখে না, এটি স্পষ্টভাবে দেখায় যে ভেরিয়েবলটি ইচ্ছাকৃতভাবে "খালি" রাখা হয়েছে।
এই কারণে null ভেরিয়েবলের জন্য কিছু মেমরি অ্যাসাইন হয়।
উদাহরণ:
let myVariable = null;
// মেমরি বরাদ্দ হয়েছে কিন্তু মান নেই (খালি হিসেবে সেট করা হয়েছে)।


২. undefined এবং মেমরি স্পেস:
যদি কোনো ভেরিয়েবলের মান undefined হয়, তাহলে মেমরি স্পেস দখল হয়, তবে তা খুব সামান্য।

undefined মানে হলো, ভেরিয়েবল ডিক্লেয়ার করা হয়েছে, কিন্তু এতে কোনো মান অ্যাসাইন করা হয়নি।
JavaScript এই ভেরিয়েবলের জন্য মেমরি বরাদ্দ করে, কারণ ভেরিয়েবল ডিক্লেয়ার করা হয়েছে।
মেমরিতে শুধুমাত্র একটি ডিফল্ট মান রাখা হয়, যা undefined।
উদাহরণ:
let myVariable;
// মেমরি বরাদ্দ হয়েছে, কিন্তু কোনো মান সেট করা হয়নি, তাই undefined।

উপসংহার:
null ভেরিয়েবলের জন্য মেমরি বরাদ্দ হয়, কারণ এটি অবজেক্ট টাইপের একটি মান।
undefined-এর জন্যও মেমরি বরাদ্দ হয়, তবে এটি খুব সামান্য, কারণ এটি ডিফল্ট মান।
তবে বাস্তবে এই পার্থক্য খুব কমই গুরুত্বপূর্ণ হয়, কারণ আধুনিক JavaScript ইঞ্জিনগুলি মেমরি ব্যবস্থাপনায় অত্যন্ত দক্ষ।



# Number Data Type : 

JavaScript-এ Number() একটি বিল্ট-ইন কন্সট্রাক্টর এবং মেথড, যা কোনো মানকে (value) সংখ্যা (number) টাইপে রূপান্তর করে। এটি সাধারণত স্ট্রিং বা অন্য কোনো ডেটা টাইপকে সংখ্যা হিসাবে কনভার্ট করতে ব্যবহৃত হয়।

Number() মেথডের কাজ:
স্ট্রিংকে সংখ্যা বানানো: কোনো স্ট্রিং যদি সংখ্যা হিসেবে রূপান্তরযোগ্য হয়, তাহলে এটি সংখ্যায় কনভার্ট করবে।
বুলিয়ান থেকে সংখ্যা: true কে ১ এবং false কে ০-তে কনভার্ট করবে।
অন্য ডেটা টাইপকে সংখ্যা বানানো: অন্যান্য ডেটা টাইপকে সম্ভাব্য সংখ্যায় রূপান্তর করবে, যদি সম্ভব হয়।
যদি কনভার্ট করা সম্ভব না হয়: যদি কোনো মানকে সংখ্যায় রূপান্তর করা সম্ভব না হয়, তাহলে এটি NaN (Not a Number) রিটার্ন করবে।

Example : 
console.log(Number("123"));   // 123 (স্ট্রিং থেকে সংখ্যা)
console.log(Number("12.34")); // 12.34 (ডেসিমাল সংখ্যা)
console.log(Number("abc"));   // NaN (রূপান্তর সম্ভব নয়)
console.log(Number(true));    // 1 (বুলিয়ান থেকে সংখ্যা)
console.log(Number(false));   // 0
console.log(Number(null));    // 0
console.log(Number(undefined)); // NaN

নোট:
Number() শুধুমাত্র মানকে কনভার্ট করে, এটি কোনো হিসাব বা সংখ্যা যোগ করার কাজ করে না।
এটি একটি স্ট্যাটিক মেথড এবং সরাসরি Number() নামে ব্যবহার করা হয়।
এটি বিশেষত তখন ব্যবহার করা হয় যখন আপনাকে নিশ্চিত করতে হয় যে কোনো মান একটি বৈধ সংখ্যা।

# parseInt() method : 

JavaScript-এ parseInt() মেথডটি একটি স্ট্রিংকে পার্স (parse) করে একটি পূর্ণসংখ্যা (integer) হিসাবে রূপান্তর করে। এটি স্ট্রিংয়ের প্রথম সংখ্যা খুঁজে নিয়ে তাকে পূর্ণসংখ্যায় কনভার্ট করে এবং বাকিটা উপেক্ষা করে।

parseInt() মেথডের কাজ:
স্ট্রিং থেকে পূর্ণসংখ্যা বের করা: স্ট্রিংয়ের শুরুতে যদি সংখ্যা থাকে, তাহলে সেটিকে একটি পূর্ণসংখ্যায় রূপান্তর করে।
ভিত্তি (radix) নির্ধারণ করা: সংখ্যা কোন ভিত্তিতে (যেমন দশমিক, বাইনারি, হেক্সাডেসিমাল ইত্যাদি) রূপান্তর করা হবে, তা radix প্যারামিটার দিয়ে নির্ধারণ করা যায়।
স্ট্রিং-এর অযথা অংশ উপেক্ষা করা: স্ট্রিংয়ে সংখ্যা ছাড়াও অন্য কোনো অক্ষর থাকলে, এটি কেবল স্ট্রিংয়ের শুরু থেকে সংখ্যাগুলো গ্রহণ করবে এবং অন্য অংশ উপেক্ষা করবে।
যদি স্ট্রিংয়ের শুরুতে বৈধ সংখ্যা না থাকে: সেক্ষেত্রে এটি NaN (Not a Number) রিটার্ন করে।

Example : 
console.log(parseInt("123"));      // 123 (স্ট্রিং থেকে পূর্ণসংখ্যা)
console.log(parseInt("123abc"));   // 123 (শুধু সংখ্যাটি নেয়)
console.log(parseInt("abc123"));   // NaN (স্ট্রিংয়ের শুরুতে সংখ্যা নেই)
console.log(parseInt("12.34"));    // 12 (ডেসিমাল অংশ বাদ দেয়)
console.log(parseInt("101", 2));   // 5 (বাইনারি থেকে দশমিক রূপান্তর)
console.log(parseInt("FF", 16));   // 255 (হেক্সাডেসিমাল থেকে দশমিক)


# Math.floor() method : 

JavaScript-এ Math.floor() একটি বিল্ট-ইন মেথড, যা প্রদত্ত সংখ্যার দশমিক অংশ বাদ দিয়ে সেটিকে সবচেয়ে কাছের ছোট পূর্ণসংখ্যায় (lower integer) রূপান্তর করে। সহজভাবে বললে, এটি সংখ্যাটিকে নিচের দিকে round করে।

Math.floor() এর কাজ:
নিচের দিকে পূর্ণসংখ্যায় রাউন্ড করা: যেকোনো দশমিক সংখ্যা থেকে দশমিক অংশ বাদ দিয়ে সবচেয়ে ছোট পূর্ণসংখ্যা ফেরত দেয়।
নেতিবাচক সংখ্যার জন্য কাজ: নেতিবাচক সংখ্যার ক্ষেত্রে এটি আরো নিচের দিকে (বড় নেতিবাচক পূর্ণসংখ্যায়) রাউন্ড করে।

Math.floor() এর সিনট্যাক্স:  Math.floor(number)

Example : 
console.log(Math.floor(4.9));   // 4 (নিচের দিকে রাউন্ড)
console.log(Math.floor(4.1));   // 4 (নিচের দিকে রাউন্ড)
console.log(Math.floor(-4.1));  // -5 (আরো নিচে রাউন্ড, বড় নেতিবাচক সংখ্যা)
console.log(Math.floor(-4.9));  // -5
console.log(Math.floor(5));     // 5 (ইতোমধ্যেই পূর্ণসংখ্যা, কোনো পরিবর্তন হয় না)


# Math.ceil() method : 
JavaScript-এ Math.ceil() একটি বিল্ট-ইন মেথড, যা প্রদত্ত সংখ্যাকে তার পরবর্তী সর্বনিম্ন বড় পূর্ণসংখ্যায় (upper integer) রাউন্ড করে। সহজ ভাষায় বললে, এটি সংখ্যাটিকে উপরের দিকে round করে।

Math.ceil() এর কাজ:

উপরের দিকে পূর্ণসংখ্যায় রাউন্ড করা: যেকোনো দশমিক সংখ্যার ক্ষেত্রে এটি তার নিকটবর্তী বড় পূর্ণসংখ্যায় নিয়ে যায়।
নেতিবাচক সংখ্যার জন্য কাজ: নেতিবাচক সংখ্যার ক্ষেত্রে এটি কম নেতিবাচক পূর্ণসংখ্যায় রাউন্ড করে (যেমন, -4.1 কে -4)।

Math.ceil() এর সিনট্যাক্স:
Math.ceil(number)
number: এটি সেই সংখ্যা যা রাউন্ড করা হবে।

Example : 
console.log(Math.ceil(4.1));   // 5 (উপরের দিকে রাউন্ড)
console.log(Math.ceil(4.9));   // 5 (উপরের দিকে রাউন্ড)
console.log(Math.ceil(-4.1));  // -4 (কম নেতিবাচক দিকে রাউন্ড)
console.log(Math.ceil(-4.9));  // -4
console.log(Math.ceil(5));     // 5 (ইতোমধ্যেই পূর্ণসংখ্যা)



JavaScript-এ Math.ceil() একটি বিল্ট-ইন মেথড, যা প্রদত্ত সংখ্যাকে তার পরবর্তী সর্বনিম্ন বড় পূর্ণসংখ্যায় (upper integer) রাউন্ড করে। সহজ ভাষায় বললে, এটি সংখ্যাটিকে উপরের দিকে round করে।

Math.ceil() এর কাজ:
উপরের দিকে পূর্ণসংখ্যায় রাউন্ড করা: যেকোনো দশমিক সংখ্যার ক্ষেত্রে এটি তার নিকটবর্তী বড় পূর্ণসংখ্যায় নিয়ে যায়।
নেতিবাচক সংখ্যার জন্য কাজ: নেতিবাচক সংখ্যার ক্ষেত্রে এটি কম নেতিবাচক পূর্ণসংখ্যায় রাউন্ড করে (যেমন, -4.1 কে -4)।
Math.ceil() এর সিনট্যাক্স:
Math.ceil(number)
number: এটি সেই সংখ্যা যা রাউন্ড করা হবে।
উদাহরণ:
console.log(Math.ceil(4.1));   // 5 (উপরের দিকে রাউন্ড)
console.log(Math.ceil(4.9));   // 5 (উপরের দিকে রাউন্ড)
console.log(Math.ceil(-4.1));  // -4 (কম নেতিবাচক দিকে রাউন্ড)
console.log(Math.ceil(-4.9));  // -4
console.log(Math.ceil(5));     // 5 (ইতোমধ্যেই পূর্ণসংখ্যা)
বাস্তব ব্যবহার:
উপরের পূর্ণসংখ্যা প্রয়োজন হলে: কোনো মানের দশমিক অংশ বাদ দিয়ে তার পরবর্তী বড় সংখ্যা পেতে।

let price = 99.01;
console.log(Math.ceil(price)); // 100
গণনায় নির্ভুল রাউন্ডিং নিশ্চিত করতে:

let pages = 9.3;
let totalPages = Math.ceil(pages); // 10
console.log(totalPages);
মুল্য নির্ধারণে: কোনো ভগ্নাংশ মূল্যকে পরবর্তী বড় সংখ্যায় নিয়ে যাওয়ার জন্য।

# Important Note about Math.floor, Math.round and Math.trunc method : 

উপরে রাউন্ডিং নিশ্চিত: এটি সর্বদা উপরের দিকে রাউন্ড করে, এমনকি নেতিবাচক সংখ্যার ক্ষেত্রেও।
অন্যান্য মেথডের সঙ্গে পার্থক্য:
Math.floor(): সংখ্যাকে নিচের দিকে রাউন্ড করে।
Math.round(): নিকটতম পূর্ণসংখ্যায় রাউন্ড করে।
Math.trunc(): শুধুমাত্র দশমিক অংশ বাদ দেয়, রাউন্ড করে না।

Example : 
console.log(Math.ceil(4.3));   // 5
console.log(Math.floor(4.3));  // 4
console.log(Math.round(4.3));  // 4
console.log(Math.trunc(4.3));  // 4


# Math.abs(x)

কাজ: প্রদত্ত সংখ্যার ঋণাত্মক চিহ্ন (negative sign) মুছে দিয়ে সংখ্যাটির ধনাত্মক (positive) মান প্রদান করে।

console.log(Math.abs(-5)); // 5
console.log(Math.abs(5));  // 5
console.log(Math.abs(0));  // 0

# Math.round(x)
কাজ: প্রদত্ত সংখ্যাকে নিকটতম পূর্ণসংখ্যায় রাউন্ড করে।

console.log(Math.round(4.5)); // 5
console.log(Math.round(4.4)); // 4

# Math.max(x, y, ...)
কাজ: প্রদত্ত সংখ্যাগুলোর মধ্যে সর্বোচ্চ মান প্রদান করে।

console.log(Math.max(1, 5, 3, 9)); // 9

# Math.min(x, y, ...)
কাজ: প্রদত্ত সংখ্যাগুলোর মধ্যে সর্বনিম্ন মান প্রদান করে।

console.log(Math.min(1, 5, 3, 9)); // 1

# Math.pow(x, y)
কাজ: x এর y তম ঘাত (power) গণনা করে।

console.log(Math.pow(2, 3)); // 8 (2^3)

# Math.sqrt(x)
কাজ: প্রদত্ত সংখ্যার বর্গমূল (square root) প্রদান করে।

console.log(Math.sqrt(9)); // 3



# toFixed() method : 

JavaScript-এ toFixed() একটি বিল্ট-ইন মেথড, যা একটি সংখ্যার দশমিকের পরে নির্দিষ্ট সংখ্যক সংখ্যা (digit) রেখে সেই সংখ্যা একটি স্ট্রিং হিসেবে রিটার্ন করে।

toFixed() এর কাজ:
দশমিকের পরে সংখ্যা নির্দিষ্ট করা: আপনি চাইলে দশমিকের পরে কতটি সংখ্যা রাখতে চান তা নির্ধারণ করতে পারেন।
সংখ্যাকে স্ট্রিং হিসেবে রিটার্ন করে: এই মেথড সর্বদা একটি স্ট্রিং রিটার্ন করে, তাই এটি সরাসরি সংখ্যার সঙ্গে গণনা করা যায় না।
toFixed() এর সিনট্যাক্স:
number.toFixed(digits)
number: সংখ্যাটি যার দশমিকের পরের অংশ নিয়ন্ত্রণ করা হবে।
digits: দশমিকের পরে কতটি সংখ্যা থাকবে তা নির্দেশ করে (ঐচ্ছিক, ডিফল্ট 0)।
উদাহরণ:
let num = 5.6789;

console.log(num.toFixed(2)); // "5.68" (দশমিকের পরে 2 সংখ্যা রাখা হয়েছে)
console.log(num.toFixed(0)); // "6" (কোনো দশমিক সংখ্যা নেই, রাউন্ড করা হয়েছে)
console.log(num.toFixed(3)); // "5.679" (দশমিকের পরে 3 সংখ্যা)
console.log(num.toFixed(6)); // "5.678900" (দশমিকের পরে 6 সংখ্যা, প্রয়োজন হলে শূন্য যোগ করে)

গুরুত্বপূর্ণ বিষয়:
স্ট্রিং রিটার্ন করে: toFixed() সর্বদা একটি স্ট্রিং রিটার্ন করে। যদি আপনাকে এটি সংখ্যা হিসেবে ব্যবহার করতে হয়, তবে রূপান্তর করতে হবে:
let num = 5.6789;
let fixedNum = parseFloat(num.toFixed(2)); // স্ট্রিংকে আবার সংখ্যায় রূপান্তর করা
console.log(fixedNum); // 5.68
রাউন্ডিং করে: এই মেথড দশমিকের পরে নির্ধারিত সংখ্যার জন্য রাউন্ডিং করে।
ব্যবহার:
অর্থ বা মূল্যের ফরম্যাটিং:

let price = 99.9912;
console.log(price.toFixed(2)); // "99.99" (মূল্যের সঠিক দশমিক স্থান রাখে)
ডেটা প্রদর্শনের সময়: গণনা বা স্ট্যাটিস্টিক্স ফলাফল নির্দিষ্ট দশমিক স্থানে দেখানোর জন্য।

let average = 10 / 3;
console.log(average.toFixed(3)); // "3.333"
সারসংক্ষেপ:
toFixed() মেথড মূলত কোনো সংখ্যার দশমিকের পরে নির্দিষ্ট সংখ্যক সংখ্যা রেখে সেই সংখ্যা ফরম্যাট করার জন্য ব্যবহৃত হয়। এটি সাধারণত অর্থনৈতিক বা বৈজ্ঞানিক হিসাবের সঠিক ফরম্যাটিং এবং ফলাফল প্রদর্শনের জন্য উপযোগী।

